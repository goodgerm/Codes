# -*- coding: utf-8 -*-
"""project_daa.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CeHiDV9-haXVRMI-9HHO-A16S8iT7eR9
"""

import numpy as np

class Particle:
    def __init__(self, position, velocity):
        self.position = position
        self.velocity = velocity
        self.best_position = position
        self.best_fitness = float('inf')

def objective_function(x):
    # Define your objective function here
    # This function should take a particle's position and return its fitness value
    return x[0]**2 + x[1]**2  # Example: minimize f(x) = x^2 + y^2

def pso_backtracking(population_size, dimensions, max_iterations, inertia_weight, cognitive_weight, social_weight, backtrack_factor):
    population = []
    global_best_position = np.zeros(dimensions)
    global_best_fitness = float('inf')

    # Initialize population
    for _ in range(population_size):
        position = np.random.uniform(-10, 10, dimensions)  # Random initial position
        velocity = np.zeros(dimensions)  # Initial velocity is zero
        particle = Particle(position, velocity)
        population.append(particle)

    for _ in range(max_iterations):
        for particle in population:
            # Evaluate fitness
            fitness = objective_function(particle.position)

            # Update particle's best position and fitness
            if fitness < particle.best_fitness:
                particle.best_position = particle.position
                particle.best_fitness = fitness

            # Update global best position and fitness
            if fitness < global_best_fitness:
                global_best_position = particle.position
                global_best_fitness = fitness

            # Update particle's velocity
            r1 = np.random.random(dimensions)
            r2 = np.random.random(dimensions)
            cognitive_component = cognitive_weight * r1 * (particle.best_position - particle.position)
            social_component = social_weight * r2 * (global_best_position - particle.position)
            particle.velocity = inertia_weight * particle.velocity + cognitive_component + social_component

            # Update particle's position with backtracking
            backtrack_count = 0
            while True:
                new_position = particle.position + particle.velocity

                # Check if the new position is within the search space
                if np.all(new_position >= -10) and np.all(new_position <= 10):
                    particle.position = new_position
                    break

                # Backtracking
                particle.velocity *= backtrack_factor
                backtrack_count += 1

                # If the particle backtracks too many times, reset its position randomly
                if backtrack_count >= 10:
                    particle.position = np.random.uniform(-10, 10, dimensions)
                    break

    return global_best_position, global_best_fitness

population_size = 50
dimensions = 2
max_iterations = 100
inertia_weight = 0.9
cognitive_weight = 1.5
social_weight = 1.5
backtrack_factor = 0.5

best_position, best_fitness = pso_backtracking(population_size, dimensions, max_iterations, inertia_weight, cognitive_weight, social_weight, backtrack_factor)
print("Best position:", best_position)
print("Best fitness:", best_fitness)